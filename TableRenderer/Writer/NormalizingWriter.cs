using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using TableRenderer.Model;

namespace TableRenderer.Writer
{
  public abstract class NormalizingWriter : ITableWriter
  {
    protected int _colIndex;
    protected IList<Column> _columns = new List<Column>();
    protected IList<MergedCell> _mergedCells = new List<MergedCell>();
    protected int _rowIndex;

    private bool _autoGeneratedColumns;
    private Stack<ElementEntry> _elem = new Stack<ElementEntry>();
    private MergedCell _mergedCache;
    private List<object> _opCache;

    protected bool NormalizeMergedCells { get; set; }

    public abstract ITableWriter Configure(IConfiguration config);

    public ITableWriter EndPart()
    {
      return EndPart(true);
    }

    public ITableWriter EndPart(bool popAutos)
    {
      ElementEntry entry;

      do
      {
        entry = _elem.Pop();
        var popped = entry.Element;
        if (_opCache != null)
        {
          _opCache.Add(EndElement.Instance);
          if (popped is Row)
          {
            var list = _opCache.ToArray();
            _opCache = null;

            try
            {
              _autoGeneratedColumns = true;
              if ((ElementEndsWith<TableBody>() && ListStartsWith<TableBody>(list))
                || (ElementEndsWith<TableHead>() && ListStartsWith<TableHead>(list)))
                _elem.Pop();
              this.StartPart(new ColGroup(), true);
              for (var i = 0; i < _columns.Count; i++)
              {
                this.StartPart(_columns[i], true);
                this.EndPart(false);
              }
              this.EndPart(false);
            }
            finally
            {
              _autoGeneratedColumns = false;
            }

            ExecuteCache(list);
          }
        }
        else
        {
          EndElem(popped);

          if (_mergedCache != null)
          {
            _mergedCache.Cache.Add(EndElement.Instance);
            if (popped is Cell)
              _mergedCache = null;
          }

          if (popped is Column)
            _colIndex++;
          else if (popped is Row)
            _rowIndex++;
          else if (popped is Cell)
          {
            _colIndex++;
            ExecuteMergedCells();
          }
        }
      }
      while (popAutos && entry.AutoGenerated && _elem.Count > 0);

      return this;
    }

    public ITableWriter StartPart(IElement elem)
    {
      return StartPart(elem, false);
    }

    public ITableWriter StartPart(IElement elem, bool autoGenerated)
    {
      if (elem is Table && !ElementEndsWith<Sheet>())
        StartPart(new Sheet(), true);
      else if ((elem is TableHead || elem is TableBody || elem is ColGroup) && !ElementEndsWith<Table>())
        StartPart(new Table(), true);
      else if (elem is Row && !ElementEndsWith<TableHead>() && !ElementEndsWith<TableBody>())
        StartPart(new TableBody(), true);
      else if (elem is Cell && !ElementEndsWith<Row>())
        StartPart(new Row(), true);
      else if (elem is Column && !ElementEndsWith<ColGroup>())
        StartPart(new ColGroup(), true);

      var entry = new ElementEntry() { Element = elem, AutoGenerated = autoGenerated };
      _elem.Push(entry);
      var col = elem as Column;
      if (!_autoGeneratedColumns && col != null)
      {
        _columns.Add(col);
      }
      if (_columns.Count < 1
        && _opCache == null
        && (elem is Row || elem is TableBody || elem is TableHead))
      {
        _opCache = new List<object>();
      }

      if (_opCache != null)
      {
        _opCache.Add(entry);
        var cell = elem as Cell;
        if (cell != null)
        {
          for (var i = 0; i < cell.ColumnSpan; i++)
          {
            col = new Column();
            if (cell.Style != null && cell.Style.Width.ToPx() > 1)
              col.Width = cell.Style.Width / cell.ColumnSpan;
            _columns.Add(col);
          }
        }
      }
      else
      {
        StartElem(elem, autoGenerated);

        if (_mergedCache != null)
          _mergedCache.Cache.Add(entry);

        var cell = elem as Cell;
        if (cell != null
          && !(cell is MergedCell)
          && NormalizeMergedCells
          && (cell.RowSpan > 1 || cell.ColumnSpan > 1))
        {
          _mergedCache = new MergedCell(cell)
          {
            StartCol = _colIndex,
            StartRow = _rowIndex
          };
          _mergedCells.Add(_mergedCache);
        }
      }

      if (elem is Row)
      {
        _colIndex = 0;
        ExecuteMergedCells();
      }
      else if (elem is ColGroup)
      {
        _colIndex = 0;
      }
      else if (elem is Sheet || elem is Table)
      {
        _rowIndex = 0;
        _columns.Clear();
        _mergedCells.Clear();
      }

      return this;
    }

    public ITableWriter Value(object value)
    {
      if (_opCache != null)
      {
        _opCache.Add(value);
      }
      else
      {
        Value(_elem.Peek().Element, value);

        if (_mergedCache != null)
          _mergedCache.Cache.Add(value);
      }
      return this;
    }

    protected abstract void StartElem(IElement elem, bool autoGenerated);
    protected abstract void Value(IElement elem, object value);
    protected abstract void EndElem(IElement elem);
    protected abstract void CloseWriter();

    public void Close()
    {
      while (_elem.Count > 0)
      {
        EndPart();
      }
      CloseWriter();
    }

    public virtual void Dispose()
    {
      this.Close();
    }

    private bool ElementEndsWith<T>()
    {
      return _elem.Count > 0 && _elem.Peek().Element is T;
    }

    private bool ListStartsWith<T>(IEnumerable<object> list)
    {
      var first = list.FirstOrDefault();
      if (first == null) return false;
      if (first is T) return true;
      if (first is ElementEntry)
        return ((ElementEntry)first).Element is T;
      return false;
    }


    private void ExecuteCache(IEnumerable<object> cache)
    {
      foreach (var obj in cache)
      {
        if (obj is IElement)
          StartPart((IElement)obj);
        else if (obj is ElementEntry)
        {
          var entry = (ElementEntry)obj;
          StartPart(entry.Element, entry.AutoGenerated);
        }
        else if (obj == EndElement.Instance)
          EndPart();
        else
          Value(obj);
      }
    }

    private void ExecuteMergedCells()
    {
      if (!NormalizeMergedCells)
        return;

      var cell = _mergedCells.FirstOrDefault(c => c.Applies(_rowIndex, _colIndex));
      while (cell != null)
      {
        ExecuteCache(cell.Cache);
        cell = _mergedCells.FirstOrDefault(c => c.Applies(_rowIndex, _colIndex));
      }
    }

    protected class EndElement
    {
      private EndElement() { }

      private static EndElement _instance = new EndElement();
      public static EndElement Instance { get { return _instance; } }
    }

    private struct ElementEntry
    {
      public IElement Element { get; set; }
      public bool AutoGenerated { get; set; }
    }
  }
}
